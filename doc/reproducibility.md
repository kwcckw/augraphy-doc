# Reproducibility
This library uses the Python standard library's [random](https://docs.python.org/3/library/random.html) module to generate pseudorandom numbers. If you want to limit nondeterministic results, consider setting the [random seed](https://docs.python.org/3/library/random.html#random.seed) in programs that use the Augraphy library, by including `random.seed(42)` in your scripts. (The number 42 is not required; feel free to choose your own memorable seed when requiring deterministic RNG).

Augraphy depends heavily on Numpy and on OpenCV, both of which have their own internal pseudorandom number generators; we therefore recommend that users of Augraphy wishing to reproduce results include the appropriate directives to set random seeds for those libraries. You can do this by including the following block at the top of your code, with your choice of `my_random_seed`:

``` python
my_random_seed = 42

random.seed(my_random_seed)
numpy.random.seed(my_random_seed)
cv2.setRNGSeed(my_random_seed)
```

For convenience, the constructor for the `AugraphyPipeline` class accepts an optional single integer random seed, and sets the `random`, `numpy`, and `cv2` seeds to that value:

``` python
my_random_seed = 42

my_pipeline = AugraphyPipeline(ink_phase=ink_phase, paper_phase=paper_phase, post_phase=post_phase, random_seed=my_random_seed)
```

---

# Per-process Randomness vs. In-process Randomness
One common misconception about setting the random seed is that this will guarantee identical pipeline runs within the same Python process. On the contrary, setting the seed will guarantee identical pipeline runs between multiple invocations of the same Python script.

For example, consider the following code:

``` python
from augraphy import *
import random
import cv2

random.seed(0)

img = cv2.imread("image.png")

augmented1 = default_augraphy_pipeline()(img)
augmented2 = default_augraphy_pipeline()(img)

cv2.imwrite("augmented1.png", augmented1)
cv2.imwrite("augmented2.png", augmented2)

print(augmented1.shape == augmented2.shape and not np.bitwise_xor(augmented1,augmented2).any())
```

Running this script once will produce the two images `augmented1.png` and `augmented2.png` in the local directory, and print `False` because two successive pipeline executions within the same Python process are not equivalent.

We can modify the script slightly to save the augmented images under different names:

``` python
...
cv2.imwrite("augmented1_new.png", augmented1)
cv2.imwrite("augmented2_new.png", augmented2)
```

Run the new script to generate `augmented1_new.png` and `augmented2_new.png`.

We can now run the following script to check whether `augmented1.png` and `augmented1_new.png`, and `augmented2.png` and `augmented2_new.png` are identical:

``` python
import cv2
import numpy as np

c1 = cv2.imread("augmented1.png")
c1_new = cv2.imread("augmented1_new.png")

c2 = cv2.imread("augmented2.png")
c2_new = cv2.imread("augmented2_new.png")

print(c1.shape == c1_new.shape and not np.bitwise_xor(c1,c1_new).any())
print(c2.shape == c2_new.shape and not np.bitwise_xor(c2,c2_new).any())
```

The print statements will report whether the shape of the images is the same, and whether there are any non-equal pixels between the two images.

``` bash
$ python3 testaugmenteds.py
True
True
```

Indeed, the images generated by pipeline executions in successive Python processes are identical, and fixing the random seed made this possible. We recommend setting the random seeds for Numpy and OpenCV, in the manner given at the top of this page.
